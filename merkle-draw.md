# Merkle Draw Protocol

#### Version: 0.1
#### Date published: December 11, 2024

## Purpose

This specification describes a protocol for a random, lottery-style, drawing where chances are represented by SHA256 hashes. The canonical application for this protocol is selecting a particular cryptocurrency transaction from a collection of transactions to reward sender(s) and/or recipient(s) included in the transaction. This reward would, most appropriately, be done in the form of an on-chain "airdrop" of funds

## Background

Bitcoin uses [Merkle trees](https://en.wikipedia.org/wiki/Merkle_tree) as part of the block header to provide an efficient means of validating that a particular transaction is contained within a given block. Comprehensive Bitcoin node and wallet libraries contain Merkle tree functionality. Given a set of "chances," represented by unique, (pseudo)random 256-bit numbers, the same Merkle tree libraries used for Bitcoin can be used to conduct a provably fair random drawing.

## Specification

### Random Drawing Procedure

1. A set of 256-bit numbers, such as those generated by the SHA-256 algorithm, are ordered: big endian, ascending (lowest value at `0` index)
2. The Merkle root of the set is calculated, using double SHA-256
3. The Merkle root is added to the original set and the set is ordered again, placing the newly included root at the proper index
4. The Merkle proof/branch for the Merkle root is calculated. The first step in the proof will be to hash the Merkle root with an existing member of the set. This member, the "hashing partner" of the Merkle root, is the winner of the drawing

## Reference Implementations

### Clients
None currently

### Libraries
None currently

### Code

Reference code for creating covenant scripts using [checkout-components](https://github.com/hansekontor/checkout-components) JavaScript library

#### Redeem Mint Vault

```js
const { 
    bcrypto: {
        Hash256,
        merkle 
    }
} = require('@hansekontor/checkout-components')
const { randomBytes } = require('crypto')

// First construct array of all transaction ids to draw from
const leafCount = 500000;
const leaves = [];
for (let i = 0; i < leafCount; i++) {
    leaves.push(randomBytes(32))
}

// Sort array in ascending order (lowest value to highest, big endian)
leaves.sort(Buffer.compare)

// Get the Merkle root
const [root, ] = merkle.createRoot(Hash256, leaves);
console.log('merkle root', root)

// Add the Merkle root into the leaves and sort again
leaves.push(root)
leaves.sort(Buffer.compare)

// Find the index of the root in the leaves array and find it's branch partner... the winner
const rootIndex = leaves.indexOf(root)
const branch = merkle.createBranch(Hash256, rootIndex, leaves)
console.log('Winning transaction ID:', branch[0].toString('hex'))

```
